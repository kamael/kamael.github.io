---
layout: post
title: "CVE-2014-0050"
categories: notes
tags: CVE分析
---

```java
        /**
         * Attempts to read more data.
         *
         * @return Number of available bytes
         * @throws IOException An I/O error occurred.
         */
        private int makeAvailable() throws IOException {
            if (pos != -1) {
                return 0;
            }

            // Move the data to the beginning of the buffer.
            total += tail - head - pad;	// total 加上新增读取的数据长度
            System.arraycopy(buffer, tail - pad, buffer, 0, pad);	// 

            // Refill buffer with new data.
            head = 0;	// 有效数据的开头
            tail = pad;	// 有效数据的结尾

            for (;;) {
                int bytesRead = input.read(buffer, tail, bufSize - tail);	// 从 tail 开始，尽量读取所有的数据
                if (bytesRead == -1) {
                    // The last pad amount is left in the buffer.
                    // Boundary can't be in there so signal an error
                    // condition.
                    final String msg = "Stream ended unexpectedly";
                    throw new MalformedStreamException(msg);
                }
                if (notifier != null) {
                    notifier.noteBytesRead(bytesRead);
                }
                tail += bytesRead; // tail 往后推，tail 的值为 buffer 里有效数据的总长

                findSeparator();
                int av = available();	// 目前已经匹配到，符合boundary的字符的数量，如果没匹配到，为0；

                if (av > 0 || pos != -1) {
                    return av;
                }
            }
        }
        
   		private void findSeparator() {
            pos = MultipartStream.this.findSeparator();	// pos 为找到的符合条件的串最后一个字母的位置
            if (pos == -1) { // 失败，没找到
                if (tail - head > keepRegion) {
                    pad = keepRegion; // boundary RAW 数据 + 4
                } else {
                    pad = tail - head; // pad 表示有用的数据长度
                }
            }
        }
        
     // MultipartStream.this.findSeparator
     protected int findSeparator() {
        int first;
        int match = 0;
        int maxpos = tail - boundaryLength;	// 最大的可能为找到的 boundary 的位置
        // head - maxpos 中，遍历寻找是否存在 boundary(--[用户输入])
        for (first = head;
        (first <= maxpos) && (match != boundaryLength); // 不等于则是没找到匹配
        first++) {
            first = findByte(boundary[0], first); // first 跳到 boundary 第一个字符出现的位置 
            if (first == -1 || (first > maxpos)) {
                return -1;
            }
            // 看一直到结尾，是否有出现 buffer 里的数据和 boundary 不同的时候，有的话匹配失败
            for (match = 1; match < boundaryLength; match++) {
                if (buffer[first + match] != boundary[match]) {
                    break;
                }
            }
        }
        // 等于则表示找到了，这个时候返回 buffer 中匹配的最后一个字母的位置
        if (match == boundaryLength) {
            return first - 1;
        }
        return -1;
    }
    
         public int available() throws IOException {
            if (pos == -1) {
                return tail - head - pad;
            }
            return pos - head;
        }
    
```