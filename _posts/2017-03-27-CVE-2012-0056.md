---
layout: post
title: "CVE-2012-0056"
categories: notes
tags: CVE分析
---

漏洞介绍：http://blog.zx2c4.com/749

评论文章：https://lwn.net/Articles/476947/，关于漏洞公布的争议。

里面提到了 http://seclists.org/fulldisclosure/2010/Sep/268，公布了一个Nday的EXP。

Nday详情：

https://web.archive.org/web/20150113043335/http://sota.gen.nz/compat1/

https://web.archive.org/web/20150113043331/http://sota.gen.nz/compat2/

第二篇提到了 https://xorl.wordpress.com/2009/08/07/cve-2007-4573-linux-kernel-ia32-system-call-emulation-vulnerability/  CVE-2007-4573 CVE-2010-3301，即一个已经修复了的漏洞，因为没有再comment里注明，导致后面reopen。

ksplice的关于Nday事件的文章 https://blogs.oracle.com/ksplice/entry/anatomy_of_an_exploit_cve

how to write a kernel exploit: https://tc.gtisc.gatech.edu/bss/2014/r/kernel-exploits.pdf

然后查ac1db1tch3z看到了https://news.ycombinator.com/item?id=5667027，年度大戏。。

回到CVE-2012-0056。

简单来说，A程序先fork一个子进程B，然后用B打开A的/proc/pid-A/mem，通过进程间通信把文件描述符fd-M传递给A。A把自己的stderr的输出和fd-M的输入绑定，然后通过exec执行su，参数为shecllcode。执行exec后，A程序就变成了su程序。由于su不能识别shellcode为一个有效的程序，因此将其原样输出。又因为A把自己的stderr的输出和fd-M的输入绑定，因此输出直接写到了/proc/pid-A/mem，即自己内存里。而su程序为超级用户，因此可以往自己的memory里写东西。通过构造shellcode覆盖掉exit函数，导致su在推出时执行shellcode，也就得到了一个root的shell。

修复方式为在open的时候检查权限，且将/proc/pid-A/mem对应的内存映像和文件描述符绑定。这样，当A程序通过exec执行su后，/proc/pid-A/mem此时对应的内存映像为新的内存印象，而stderr绑定的文件描述符对应的为旧的，即A原本的内存映像，这样通过该描述符就无法修改su的内存映像了。








